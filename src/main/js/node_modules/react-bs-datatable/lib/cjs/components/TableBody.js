"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptyTablePlaceholder = exports.TableRow = exports.TableBody = void 0;
const react_1 = __importDefault(require("react"));
const react_bootstrap_1 = require("react-bootstrap");
const object_1 = require("../helpers/object");
const DatatableWrapper_1 = require("./DatatableWrapper");
const hooks_1 = require("../helpers/hooks");
/**
 * Renders the table body, which is a `tbody` tag along with the rest of the elements,
 * such as `tr` and `td` tags.
 */
function TableBody({ labels, classes, rowProps, onRowClick: onRowClickProp, controlledProps, children }) {
    const { data } = (0, DatatableWrapper_1.useDatatableWrapper)();
    (0, hooks_1.useControlledStateSetter)(controlledProps);
    let bodyContent;
    if (children) {
        if (typeof children === 'function') {
            bodyContent = children(data);
        }
        else {
            bodyContent = children;
        }
    }
    else {
        const body = [];
        const dataLength = data.length;
        if (dataLength > 0) {
            for (let rowIdx = 0; rowIdx < dataLength; rowIdx++) {
                // Push to array.
                body.push(react_1.default.createElement(TableRow, { key: rowIdx, rowData: data[rowIdx], rowIdx: rowIdx, rowProps: rowProps, classes: { td: classes === null || classes === void 0 ? void 0 : classes.td, tr: classes === null || classes === void 0 ? void 0 : classes.tr }, controlledProps: controlledProps, onRowClick: onRowClickProp }));
            }
        }
        else {
            body.push(react_1.default.createElement(EmptyTablePlaceholder, { key: "row-zero-length", noResultsLabel: labels === null || labels === void 0 ? void 0 : labels.noResults }));
        }
        bodyContent = body;
    }
    return (react_1.default.createElement("tbody", { className: (0, object_1.makeClasses)('tbody', classes === null || classes === void 0 ? void 0 : classes.tbody) }, bodyContent));
}
exports.TableBody = TableBody;
// Composing functions.
const VALID_TAGS_FOR_ROW_ONCLICK = ['TD', 'TR'];
/**
 * `TableRow` component, as its name suggests, is a component to render a row of a table.
 * This component is exported so it is possible to compose the rows further. For example:
 *
 * ```
 * <TableBody>
 *   {
 *     data.map((row, rowIdx) => (
 *       row.isLoading ? (
 *         <tr><td colSpan={headers.length}><Loading /></td></tr>
 *       ) : (
 *         <TableRow rowData={row} rowIdx={rowIdx} />
 *       )
 *     ))
 *   }
 * </TableBody>
 * ```
 *
 * The above snippet will render loading indicator for rows that don't have sufficient data to store yet.
 */
function TableRow({ rowData, rowIdx, onRowClick: onRowClickProp, classes, controlledProps, rowProps }) {
    const { headers, onCheckboxChange: onCheckboxChangeContext, checkboxState: checkboxStateContext, filteredDataLength: filteredDataLengthContext, data } = (0, DatatableWrapper_1.useDatatableWrapper)();
    const headersLength = headers.length;
    function onRowClick(event) {
        if (typeof onRowClickProp === 'function') {
            if (event.target instanceof HTMLElement &&
                VALID_TAGS_FOR_ROW_ONCLICK.includes(event.target.tagName)) {
                onRowClickProp(rowData, event);
            }
        }
    }
    const onCheckboxChange = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.onCheckboxChange) || onCheckboxChangeContext;
    const checkboxState = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.checkboxState) || checkboxStateContext;
    const filteredDataLength = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.filteredDataLength) || filteredDataLengthContext;
    const { createColumnCheckboxClickHandler } = (0, hooks_1.useCreateCheckboxHandlers)({
        checkboxState,
        data,
        filteredDataLength,
        onCheckboxChange
    });
    const row = [];
    for (let colIdx = 0; colIdx < headersLength; colIdx++) {
        const { cell, cellProps = {}, prop: rawProp, checkbox, alignment } = headers[colIdx];
        const prop = rawProp.toString();
        let value = '';
        if (checkbox && checkboxState) {
            // Render checkbox.
            const idValue = rowData[checkbox.idProp];
            const isSelected = checkboxState[prop].selected.has(idValue);
            // Source for using visually hidden: https://www.w3.org/WAI/tutorials/forms/labels/#hiding-the-label-element.
            value = (react_1.default.createElement(react_bootstrap_1.Form.Group, { controlId: `table-selection-${rowData[checkbox.idProp]}` },
                react_1.default.createElement(react_bootstrap_1.Form.Label, { className: "visually-hidden" }, isSelected
                    ? `Remove ${idValue} from selection`
                    : `Add ${idValue} to selection`),
                react_1.default.createElement(react_bootstrap_1.Form.Check, { type: "checkbox", name: "table-selection", value: rowData[checkbox.idProp], className: checkbox.className, checked: checkboxState[prop].selected.has(idValue), onChange: createColumnCheckboxClickHandler({
                        checkboxProp: prop,
                        idProp: checkbox.idProp,
                        rowIdx
                    }) })));
        }
        else {
            // Render normally.
            if (cell === undefined) {
                value = rowData[prop];
            }
            else {
                value = cell(rowData);
            }
        }
        row.push(react_1.default.createElement("td", { key: `col-${colIdx}`, className: (0, object_1.makeClasses)('tbody-td', classes === null || classes === void 0 ? void 0 : classes.td, 
            // Alignment.
            {
                'text-start': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'left',
                'text-center': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'center',
                'text-end': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'right'
            }, typeof cellProps.className === 'function'
                ? cellProps.className(rowData)
                : cellProps.className), style: typeof cellProps.style === 'function'
                ? cellProps.style(rowData)
                : cellProps.style }, value));
    }
    let passedRowProps = {};
    if (typeof rowProps === 'function') {
        passedRowProps = rowProps(rowData);
    }
    else if (rowProps !== undefined) {
        passedRowProps = rowProps;
    }
    return (react_1.default.createElement("tr", Object.assign({}, passedRowProps, { className: (0, object_1.makeClasses)('tbody-tr', classes === null || classes === void 0 ? void 0 : classes.tr, passedRowProps === null || passedRowProps === void 0 ? void 0 : passedRowProps.className), onClick: onRowClick }), row));
}
exports.TableRow = TableRow;
/**
 * `EmptyTablePlaceholder` is a component used to indicate that a table is empty, or doesn't
 * have matching search results.
 *
 * @param param0
 * @returns
 */
function EmptyTablePlaceholder({ className, noResultsLabel }) {
    const { headers } = (0, DatatableWrapper_1.useDatatableWrapper)();
    return (react_1.default.createElement("tr", { className: (0, object_1.makeClasses)('tbody-tr', className) },
        react_1.default.createElement("td", { className: "tbody-td", colSpan: headers.length }, noResultsLabel || 'No results to be shown.')));
}
exports.EmptyTablePlaceholder = EmptyTablePlaceholder;
