"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableHeader = void 0;
const react_1 = __importDefault(require("react"));
const react_bootstrap_1 = require("react-bootstrap");
const DatatableWrapper_1 = require("./DatatableWrapper");
const FontAwesome_1 = __importDefault(require("./FontAwesome"));
const object_1 = require("../helpers/object");
const data_1 = require("../helpers/data");
const hooks_1 = require("../helpers/hooks");
/**
 * Renders a list of table headers.
 */
function TableHeader({ classes, controlledProps }) {
    const headings = [];
    const { headers, onSortChange: onSortChangeContext, sortState: sortStateContext, onCheckboxChange: onCheckboxChangeContext, checkboxState: checkboxStateContext, filteredDataLength: filteredDataLengthContext, data } = (0, DatatableWrapper_1.useDatatableWrapper)();
    (0, hooks_1.useControlledStateSetter)(controlledProps);
    const onSortChange = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.onSortChange) || onSortChangeContext;
    const sortState = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.sortState) || sortStateContext;
    const onCheckboxChange = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.onCheckboxChange) || onCheckboxChangeContext;
    const checkboxState = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.checkboxState) || checkboxStateContext;
    const filteredDataLength = (controlledProps === null || controlledProps === void 0 ? void 0 : controlledProps.filteredDataLength) || filteredDataLengthContext;
    const { createHeaderCheckboxClickHandler } = (0, hooks_1.useCreateCheckboxHandlers)({
        checkboxState,
        data,
        filteredDataLength,
        onCheckboxChange
    });
    for (let i = 0; i < headers.length; i += 1) {
        const { isSortable, prop: rawProp, title, headerCell, thProps: additionalThProps = {}, checkbox, alignment } = headers[i];
        const prop = rawProp.toString();
        const { className: headerPropsClassName } = additionalThProps, rest = __rest(additionalThProps, ["className"]);
        const thClass = (0, object_1.makeClasses)({
            'thead-th': true,
            sortable: isSortable === true
        });
        const isCurrentSort = sortState.prop === prop;
        const thProps = Object.assign({ key: `th-${i}`, className: (0, object_1.makeClasses)(thClass, classes === null || classes === void 0 ? void 0 : classes.th, headerPropsClassName, 
            // Alignment.
            {
                'text-start': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'left',
                'text-center': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'center',
                'text-end': (alignment === null || alignment === void 0 ? void 0 : alignment.horizontal) === 'right'
            }) }, rest);
        let sortIcon = 'sort';
        let sortIconRender = null;
        if (isSortable && !checkbox) {
            if (isCurrentSort) {
                // Depending on the sort order, add a `data-sort-order` attribute,
                // which is mostly for testing, as well as setting the icons and
                // the next sort type which will be used in the on click event.
                thProps['data-sort-order'] = sortState.order;
                if (sortState.order === 'asc') {
                    sortIcon = 'sortUp';
                }
                else {
                    sortIcon = 'sortDown';
                }
            }
            thProps.onClick = () => onSortChange((0, data_1.getNextSortState)(sortState, prop));
            thProps.role = 'button';
            sortIconRender = react_1.default.createElement(FontAwesome_1.default, { icon: sortIcon, className: "fa-fw" });
        }
        let rendered;
        if (checkbox) {
            let numberOfSelectedRowsInCurrentPage = 0;
            let nextCheckboxType;
            for (const row of data) {
                if (checkboxState[prop].selected.has(row[checkbox.idProp])) {
                    numberOfSelectedRowsInCurrentPage += 1;
                }
            }
            if (numberOfSelectedRowsInCurrentPage === data.length) {
                nextCheckboxType = 'remove';
            }
            else {
                nextCheckboxType = 'add';
            }
            // Source for using visually hidden: https://www.w3.org/WAI/tutorials/forms/labels/#hiding-the-label-element.
            rendered = (react_1.default.createElement(react_bootstrap_1.Form.Group, { controlId: `table-selection-all` },
                react_1.default.createElement(react_bootstrap_1.Form.Label, { className: "visually-hidden" }, nextCheckboxType === 'add'
                    ? `Add ${data.length - numberOfSelectedRowsInCurrentPage} rows to selection`
                    : `Remove ${numberOfSelectedRowsInCurrentPage} rows from selection`),
                react_1.default.createElement(react_bootstrap_1.Form.Check, { type: "checkbox", name: "table-selection", value: "all", className: checkbox.className, checked: checkboxState[prop].state === 'all-selected', ref: (node) => {
                        if (node !== null) {
                            node.indeterminate =
                                checkboxState[prop].state === 'some-selected';
                        }
                    }, onChange: createHeaderCheckboxClickHandler({
                        checkboxProp: prop,
                        idProp: checkbox.idProp
                    }) })));
        }
        else if (headerCell) {
            rendered = headerCell(sortIconRender, sortState);
        }
        else {
            rendered = (react_1.default.createElement(react_1.default.Fragment, null,
                title,
                react_1.default.createElement("span", null, sortIconRender)));
        }
        headings.push(react_1.default.createElement("th", Object.assign({}, thProps), rendered));
    }
    return (react_1.default.createElement("thead", { className: (0, object_1.makeClasses)('thead', classes === null || classes === void 0 ? void 0 : classes.thead) },
        react_1.default.createElement("tr", { className: (0, object_1.makeClasses)('thead-tr', classes === null || classes === void 0 ? void 0 : classes.tr) }, headings)));
}
exports.TableHeader = TableHeader;
