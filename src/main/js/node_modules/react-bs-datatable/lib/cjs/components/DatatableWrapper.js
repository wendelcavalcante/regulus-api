"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatatableWrapper = exports.useDatatableWrapper = void 0;
const react_1 = __importStar(require("react"));
const data_1 = require("../helpers/data");
const object_1 = require("../helpers/object");
const react_2 = require("../helpers/react");
const [useCtx, Provider] = (0, react_2.createCtx)();
/**
 * @internal
 *
 * This is an internal hook to use in all table components.
 */
exports.useDatatableWrapper = useCtx;
function DatatableWrapper({ headers, body, isControlled: isControlledProp, filterProps, sortProps, paginationProps, paginationOptionsProps, checkboxProps, tableEventsRef, children }) {
    const [state, setState] = (0, react_1.useState)(getDefaultDatatableState({
        filterProps,
        headers,
        sortProps,
        paginationProps,
        paginationOptionsProps,
        checkboxProps
    }));
    const [isControlled, setIsControlled] = (0, react_1.useState)(isControlledProp || false);
    const headersRecordRef = (0, react_1.useRef)((0, object_1.convertArrayToRecord)(headers, 'prop'));
    // Store this in a ref because we might need it in case `headers` change.
    // Though, we don't want to put these into `useEffect` because they most likely
    // change over time.
    const controlPropsRef = (0, react_1.useRef)({
        filterProps,
        sortProps,
        paginationProps,
        paginationOptionsProps,
        checkboxProps
    });
    const { previouslyModifiedCheckboxRef } = useTableHeaderCheckbox();
    (0, react_1.useEffect)(() => {
        if (tableEventsRef !== undefined) {
            console.warn('Warning: Usage of `tableEventsRef` is deprecated. Consider using `useDatatableWrapper`' +
                'and raising the `DatatableWrapper` a bit higher in the structure instead.');
        }
    }, [tableEventsRef]);
    (0, react_1.useEffect)(() => {
        // Resets the table if the headers passed down is different.
        if (headers !== undefined && !isControlled) {
            // Re-set the ref.
            headersRecordRef.current = (0, object_1.convertArrayToRecord)(headers, 'prop');
            // Re-set the initial state.
            setState(getDefaultDatatableState({
                filterProps: controlPropsRef.current.filterProps,
                headers,
                sortProps: controlPropsRef.current.sortProps,
                paginationProps: controlPropsRef.current.paginationProps,
                paginationOptionsProps: controlPropsRef.current.paginationOptionsProps,
                checkboxProps: controlPropsRef.current.checkboxProps
            }));
        }
    }, [headers, isControlled]);
    (0, react_1.useEffect)(() => {
        // Resets the table if the data passed down is different.
        if (body !== undefined && !isControlled) {
            setState((oldState) => (Object.assign(Object.assign({}, oldState), { filter: '', pagination: Object.assign(Object.assign({}, oldState.pagination), { currentPage: 1 }) })));
        }
    }, [body, isControlled]);
    const onFilterChange = (0, react_1.useCallback)((text) => {
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { filter: text, pagination: Object.assign(Object.assign({}, oldState.pagination), { currentPage: 1 }) })));
    }, []);
    const onPaginationChange = (0, react_1.useCallback)((nextPage) => {
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { pagination: Object.assign(Object.assign({}, oldState.pagination), { currentPage: nextPage }) })));
    }, []);
    const onRowsPerPageChange = (0, react_1.useCallback)((numOfPage) => {
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { pagination: Object.assign(Object.assign({}, oldState.pagination), { rowsPerPage: numOfPage, currentPage: 1 }) })));
    }, []);
    const onSortChange = (0, react_1.useCallback)((nextSort) => {
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { sort: nextSort })));
    }, []);
    const onSortByPropChange = (0, react_1.useCallback)((sortedProp) => {
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { sort: (0, data_1.getNextSortState)(oldState.sort, sortedProp) })));
    }, []);
    const onCheckboxChange = (0, react_1.useCallback)((result, event) => {
        var _a;
        // This is put here so that if we modify `result`, it'll be taken into account when we destructure it on the following line.
        (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onCheckboxChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, result, event);
        const { checkboxProp, nextCheckboxState } = result;
        setState((oldState) => (Object.assign(Object.assign({}, oldState), { checkbox: Object.assign(Object.assign({}, oldState.checkbox), { [checkboxProp]: nextCheckboxState }) })));
    }, [checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onCheckboxChange]);
    // Imperative handle.
    // This is if we want to keep the table events controllable from outside,
    // without making the table controlled.
    // TODO(imballinst): rethink about this for the next major version (4.x).
    // https://github.com/imballinst/react-bs-datatable/pull/123#issuecomment-1050582200.
    (0, react_1.useImperativeHandle)(tableEventsRef, () => ({
        onFilterChange,
        onPaginationChange,
        onRowsPerPageChange,
        onSortByPropChange,
        onCheckboxChange
    }), []);
    const { filter, sort, pagination, isFilterable } = state;
    const { data, filteredDataLength, maxPage } = (0, react_1.useMemo)(() => {
        let newData = body;
        let newFilteredDataLength = newData.length;
        let newMaxPage = 1;
        if (!isControlled) {
            // Only do this in uncontrolled mode.
            if (isFilterable) {
                newData = (0, data_1.filterData)(body, headersRecordRef.current, filter);
                newFilteredDataLength = newData.length;
            }
            newData = (0, data_1.sortData)(newData, sort, sortProps === null || sortProps === void 0 ? void 0 : sortProps.sortValueObj);
            if (pagination.rowsPerPage !== -1) {
                // Pagination needs.
                newMaxPage = Math.ceil(newData.length / pagination.rowsPerPage);
                newData = (0, data_1.paginateData)(newData, pagination.currentPage, pagination.rowsPerPage);
            }
        }
        return {
            data: newData,
            maxPage: newMaxPage,
            filteredDataLength: newFilteredDataLength
        };
    }, [isControlled, body, filter, sort, pagination, isFilterable]);
    return (react_1.default.createElement(Provider, { value: {
            headers,
            isControlled,
            setIsControlled,
            // Filter.
            isFilterable: isFilterable,
            filterState: filter,
            onFilterChange,
            // Sort.
            sortState: sort,
            onSortChange,
            onSortByPropChange,
            // Pagination.
            currentPageState: pagination.currentPage,
            onPaginationChange,
            // Pagination options.
            rowsPerPageState: pagination.rowsPerPage,
            rowsPerPageOptions: pagination.rowsPerPageOptions,
            onRowsPerPageChange,
            // Checkbox.
            checkboxState: state.checkbox,
            previouslyModifiedCheckbox: previouslyModifiedCheckboxRef,
            onCheckboxChange,
            // Data.
            maxPage,
            filteredDataLength,
            data,
            body
        } }, children));
}
exports.DatatableWrapper = DatatableWrapper;
// Helper functions.
function getDefaultDatatableState({ filterProps, paginationOptionsProps, paginationProps, sortProps, checkboxProps, headers }) {
    var _a, _b, _c, _d;
    const defaultSort = (sortProps === null || sortProps === void 0 ? void 0 : sortProps.initialState) || {
        order: 'asc',
        prop: ''
    };
    const checkbox = (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.initialState) || {};
    let isFilterable = filterProps !== undefined;
    for (const header of headers) {
        const prop = header.prop.toString();
        if (defaultSort.prop === '' && header.isSortable) {
            // If the sorted prop is still "empty", then we assign it with the current header.
            defaultSort.prop = String(header.prop);
        }
        // Set the default checkbox values, if not provided from `checkboxProps`.
        if (header.checkbox && (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.initialState) === undefined) {
            checkbox[prop] = { state: 'none-selected', selected: new Set() };
        }
        if (header.isFilterable) {
            isFilterable = true;
        }
    }
    // Define initial state.
    return {
        isFilterable,
        filter: ((_a = filterProps === null || filterProps === void 0 ? void 0 : filterProps.initialState) === null || _a === void 0 ? void 0 : _a.filter) || '',
        sort: defaultSort,
        pagination: {
            currentPage: ((_b = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.initialState) === null || _b === void 0 ? void 0 : _b.page) || 1,
            rowsPerPage: ((_c = paginationOptionsProps === null || paginationOptionsProps === void 0 ? void 0 : paginationOptionsProps.initialState) === null || _c === void 0 ? void 0 : _c.rowsPerPage) || -1,
            rowsPerPageOptions: ((_d = paginationOptionsProps === null || paginationOptionsProps === void 0 ? void 0 : paginationOptionsProps.initialState) === null || _d === void 0 ? void 0 : _d.options) || []
        },
        checkbox
    };
}
function useTableHeaderCheckbox() {
    const previouslyModifiedCheckboxRef = (0, react_1.useRef)({
        checkboxProp: '',
        idProp: ''
    });
    return { previouslyModifiedCheckboxRef };
}
