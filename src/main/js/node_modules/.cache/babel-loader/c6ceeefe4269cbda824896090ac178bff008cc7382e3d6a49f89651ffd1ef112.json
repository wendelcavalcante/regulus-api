{"ast":null,"code":"export function getPageNumbers({\n  currentPageState,\n  prevPageNumbers,\n  paginationRange,\n  maxPage\n}) {\n  const isEven = paginationRange % 2 === 0;\n  let numberOfButtonsToEdges = Math.floor(paginationRange / 2);\n  if (isEven) {\n    // When it's even, then there should be 2 buttons in the center.\n    numberOfButtonsToEdges -= 1;\n  }\n  if (prevPageNumbers && isEven) {\n    const index = prevPageNumbers.indexOf(currentPageState);\n    if (index >= 0) {\n      const shiftRightIndexStart = prevPageNumbers.length - 1 - numberOfButtonsToEdges;\n      if (index >= 0 && index < numberOfButtonsToEdges) {\n        // Shift left.\n        const numberOfShifts = index - numberOfButtonsToEdges;\n        const startNumber = normalizeStartNumber(prevPageNumbers[0] + numberOfShifts);\n        return getRange(startNumber, startNumber + paginationRange, maxPage);\n      } else if (index >= shiftRightIndexStart && index < maxPage) {\n        // Shift right.\n        const numberOfShifts = numberOfButtonsToEdges - (paginationRange - index - 1);\n        let startNumber = normalizeStartNumber(prevPageNumbers[0] + numberOfShifts);\n        if (maxPage - startNumber + 1 < paginationRange) {\n          startNumber = normalizeStartNumber(maxPage - paginationRange + 1);\n        }\n        return getRange(startNumber, startNumber + paginationRange, maxPage);\n      } else {\n        // For example, from this:\n        // 4, 5, [6], 7, 8, 9\n        //\n        // to this:\n        // 4, 5, 6, [7], 8, 9\n        //\n        // In that case, we don't need to \"create\" a new page numbers. Just reuse the old one.\n        // Another example:\n        //\n        // 1, 2, [3], 4, 5, 6 --> 1, [2], 3, 4, 5, 6\n        // 5, 6, 7, [8], 9, 10 --> 5, 6, 7, 8, [9], 10 (assuming 10 is the maxPage)\n        return prevPageNumbers;\n      }\n    }\n  }\n  // Build fresh.\n  let startNumber;\n  if (currentPageState === 1) {\n    // Active button is the first one.\n    startNumber = 1;\n  } else if (currentPageState === maxPage && maxPage !== 1) {\n    // Active button is in the last.\n    startNumber = maxPage - paginationRange + 1 > 0 ? currentPageState - paginationRange + 1 : 1;\n  } else {\n    // Active button is in the middle.\n    startNumber = currentPageState - numberOfButtonsToEdges;\n    // If max page is \"around the corner\", then we need to make the max page to be in the last button.\n    if (startNumber + paginationRange > maxPage) {\n      startNumber = maxPage - paginationRange + 1;\n    }\n    // If somehow the start number is 0 or negative, we set it back to 1.\n    if (startNumber < 1) startNumber = 1;\n  }\n  return getRange(startNumber, startNumber + paginationRange, maxPage);\n}\nfunction getRange(from, to, maxPage) {\n  const pageNumbers = [];\n  let i = from;\n  while (i < to && i <= maxPage) {\n    pageNumbers.push(i);\n    i += 1;\n  }\n  return pageNumbers;\n}\nfunction normalizeStartNumber(val) {\n  return val <= 0 ? 1 : val;\n}","map":{"version":3,"names":["getPageNumbers","currentPageState","prevPageNumbers","paginationRange","maxPage","isEven","numberOfButtonsToEdges","Math","floor","index","indexOf","shiftRightIndexStart","length","numberOfShifts","startNumber","normalizeStartNumber","getRange","from","to","pageNumbers","i","push","val"],"sources":["/home/wendel/desen/regulus/node_modules/react-bs-datatable/lib/esm/helpers/pagination.js"],"sourcesContent":["export function getPageNumbers({ currentPageState, prevPageNumbers, paginationRange, maxPage }) {\n    const isEven = paginationRange % 2 === 0;\n    let numberOfButtonsToEdges = Math.floor(paginationRange / 2);\n    if (isEven) {\n        // When it's even, then there should be 2 buttons in the center.\n        numberOfButtonsToEdges -= 1;\n    }\n    if (prevPageNumbers && isEven) {\n        const index = prevPageNumbers.indexOf(currentPageState);\n        if (index >= 0) {\n            const shiftRightIndexStart = prevPageNumbers.length - 1 - numberOfButtonsToEdges;\n            if (index >= 0 && index < numberOfButtonsToEdges) {\n                // Shift left.\n                const numberOfShifts = index - numberOfButtonsToEdges;\n                const startNumber = normalizeStartNumber(prevPageNumbers[0] + numberOfShifts);\n                return getRange(startNumber, startNumber + paginationRange, maxPage);\n            }\n            else if (index >= shiftRightIndexStart && index < maxPage) {\n                // Shift right.\n                const numberOfShifts = numberOfButtonsToEdges - (paginationRange - index - 1);\n                let startNumber = normalizeStartNumber(prevPageNumbers[0] + numberOfShifts);\n                if (maxPage - startNumber + 1 < paginationRange) {\n                    startNumber = normalizeStartNumber(maxPage - paginationRange + 1);\n                }\n                return getRange(startNumber, startNumber + paginationRange, maxPage);\n            }\n            else {\n                // For example, from this:\n                // 4, 5, [6], 7, 8, 9\n                //\n                // to this:\n                // 4, 5, 6, [7], 8, 9\n                //\n                // In that case, we don't need to \"create\" a new page numbers. Just reuse the old one.\n                // Another example:\n                //\n                // 1, 2, [3], 4, 5, 6 --> 1, [2], 3, 4, 5, 6\n                // 5, 6, 7, [8], 9, 10 --> 5, 6, 7, 8, [9], 10 (assuming 10 is the maxPage)\n                return prevPageNumbers;\n            }\n        }\n    }\n    // Build fresh.\n    let startNumber;\n    if (currentPageState === 1) {\n        // Active button is the first one.\n        startNumber = 1;\n    }\n    else if (currentPageState === maxPage && maxPage !== 1) {\n        // Active button is in the last.\n        startNumber =\n            maxPage - paginationRange + 1 > 0\n                ? currentPageState - paginationRange + 1\n                : 1;\n    }\n    else {\n        // Active button is in the middle.\n        startNumber = currentPageState - numberOfButtonsToEdges;\n        // If max page is \"around the corner\", then we need to make the max page to be in the last button.\n        if (startNumber + paginationRange > maxPage) {\n            startNumber = maxPage - paginationRange + 1;\n        }\n        // If somehow the start number is 0 or negative, we set it back to 1.\n        if (startNumber < 1)\n            startNumber = 1;\n    }\n    return getRange(startNumber, startNumber + paginationRange, maxPage);\n}\nfunction getRange(from, to, maxPage) {\n    const pageNumbers = [];\n    let i = from;\n    while (i < to && i <= maxPage) {\n        pageNumbers.push(i);\n        i += 1;\n    }\n    return pageNumbers;\n}\nfunction normalizeStartNumber(val) {\n    return val <= 0 ? 1 : val;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}